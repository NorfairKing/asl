\documentclass[11pt]{article}
\usepackage[a4paper, portrait, margin=1in]{geometry}

\usepackage{mathtools}
\usepackage{float}

\input{../common.tex}

\begin{document}

\title{Advanced Systems Lab (Fall'16) -- Second
Milestone}

\author{Name: \emph{\myname}\\Legi number: \emph{\myleginr}}

\date{
\vspace{4cm}
\textbf{Grading} \\
\begin{tabular}{|c|c|}
\hline  \textbf{Section} & \textbf{Points} \\ 
\hline  1 &  \\ 
\hline  2 &  \\ 
\hline  3 &  \\ 
\hline \hline Total & \\
\hline 
\end{tabular} 
}

\maketitle

\newpage

\section{Introduction}

This is the second report in a series of three reports for the the advanced systems lab.
In this course we implement and investigate the performance of a middleware for memcached.
This part focusses mostly on investigating the performance of the system that was built for the previous part.


\section{Fixes and upgrades}

The middleware has changed since the last part to improve its efficiency.
It no longer constructs the extremely verbose logging messages that it used to.
Even though these messages were never printed, they were still constructed because of Java's strict evaluation semantics.

\TODO{re-run stability trace?}

\section{Maximum Throughput}
% Find the highest throughput of your system for 5 servers with no replication and a read-only workload configuration. What is the minimum number of threads and clients (rounded to multiple of 10) that together achieve this throughput? Explain why the system reaches its maximum throughput at these points and show how the performance changes around these configurations. Provide a detailed breakdown of the time spent in the middleware for each operation type.

\subsection{System under test}

In the first experiment, the middleware is in charge of five servers with no replication and a read-only workload configuration.
The aim is to investigate which combination of the total number of clients and the number of threads in each server's thread pool for reads achieves the highest throughput.
The details of the explored configuration can be found in figure \TODO{which figure?}.

\begin{figure}[H]
  \centering
  \input{\genfile{remote-maximum-throughput-table.tex}}
  \caption{Maximum throughput experiments}
\end{figure}

% \begin{figure}[H]
%   \centering
%   \input{\genfile{big-remote-maximum-throughput-table.tex}}
%   \caption{Big Maximum throughput experiments}
% \end{figure}

\subsection{Hypothesis}

Making an accurate estimate of the configuration that achieves the highest throughput is hard if not unnecessary.
What is more important is to estimate what will happen as we increase the total number of virtual clients or the number of threads in each server's thread pool for reads.

\subsubsection{Increasing the total number of virtual clients}

As the middleware operates with an unbounded queue of requests to process, it never drops requests even if the load increses.
(We assume that the limits of memory are not reached.
This assumption is reasonable as the middleware machine that will be used has 14 GiB of main memory.)

As the total number of virtual clients increases, we expect to see throughput increase up to a certain point.
This is the point at which request are never empty.
From then on the throughput should not increase any further as subsequents will just be punt onto the queue and requests will not be processed any quicker.

\subsubsection{Increasing the number of clients in each server's thread pool for reads}

Reads are executed in a synchronous manner.
This means that each read thread can perform at most one request per round-trip time.
\TODO{implement the synchronous thingies correctly!!}

\subsection{Results and analysis}

Figure \ref{fig:maximum-throughput-throughput} shows that throughput tends to increase as the number of clients increases.
It also shows that an increase in the number of clients has diminishisng effects past \FIWRD clients.
Past this point, the average total throughput levels off at about \FIWRD transactions per second.

\TODO{Mention the effect of the number of threads}

\begin{figure}
  \centering
    \includegraphics[width=0.32\textwidth]{\plot{remote-maximum-throughput-maximum-throughput-1.png}}
    \includegraphics[width=0.32\textwidth]{\plot{remote-maximum-throughput-maximum-throughput-9.png}}
    \includegraphics[width=0.32\textwidth]{\plot{remote-maximum-throughput-maximum-throughput-17.png}}
    \includegraphics[width=0.32\textwidth]{\plot{remote-maximum-throughput-maximum-throughput-25.png}}
    \includegraphics[width=0.32\textwidth]{\plot{remote-maximum-throughput-maximum-throughput-33.png}}
  \caption{Maximum Throughput}
\end{figure}

Figure \ref{fig:maximum-throughput-trace-slice-1-thread-absolute} and \ref{fig:maximum-throughput-trace-slice-1-thread-relative} show a detailed breakdown of where each requests spends time in the middleware.
Figure \ref{fig:maximum-throughput-trace-slice-1-thread-absolute} shows the average absolute time spent in the middleware for a request.
Figure \ref{fig:maximum-throughput-trace-slice-1-thread-relative} shows the same data, but the time is shown in percentages relative to the total average amount of time spent per request.

Figure \ref{fig:maximum-throughput-trace-slice-1-thread-absolute} shows that, as the number of clients increases, the only part that takes significantly longer is the time that an average requests spends in the queue, waiting to be forwarded to a server.
Figure \ref{fig:maximum-throughput-trace-slice-1-thread-relative} shows that, as the number of clients increases, the time that an average request spends on the queue becomes the most significant component of the total time spent in the middleware.
In fact, it becomes more than ten \FIWRD times more significant than any other part of the waiting time.

Figure TODO shows that the situation is similar when the middleware uses six \FIWRD threads per read pool.
The total time spent in the middleware is lower for an average request, but essentially the same problem occurs.
The average request spends the majority of its time in the middleware on a queue waiting to be forwarded to a server, and this part of the time spent becomes increasingly significant as the number of clients increases, just like before.

\begin{figure}
  \centering
    \includegraphics[width=0.48\textwidth]{\plot{remote-maximum-throughput-slice-absolute-1-slice.png}}
    \includegraphics[width=0.48\textwidth]{\plot{remote-maximum-throughput-slice-relative-1-slice.png}}
    \includegraphics[width=0.48\textwidth]{\plot{remote-maximum-throughput-slice-absolute-9-slice.png}}
    \includegraphics[width=0.48\textwidth]{\plot{remote-maximum-throughput-slice-relative-9-slice.png}}
    \includegraphics[width=0.48\textwidth]{\plot{remote-maximum-throughput-slice-absolute-17-slice.png}}
    \includegraphics[width=0.48\textwidth]{\plot{remote-maximum-throughput-slice-relative-17-slice.png}}
    \includegraphics[width=0.48\textwidth]{\plot{remote-maximum-throughput-slice-absolute-25-slice.png}}
    \includegraphics[width=0.48\textwidth]{\plot{remote-maximum-throughput-slice-relative-25-slice.png}}
    \includegraphics[width=0.48\textwidth]{\plot{remote-maximum-throughput-slice-absolute-33-slice.png}}
    \includegraphics[width=0.48\textwidth]{\plot{remote-maximum-throughput-slice-relative-33-slice.png}}
  \caption{Maximum Throughput Trace Slice}
\end{figure}


\section{Effect of Replication}

% Explore how the behavior of your system changes for a 5\%-write workload with S=3,5 and 7 server backends and the following three replication factors:
% \begin{itemize} 
% \item Write to $1$ (no replication) 
% \item Write to $\ceil{\frac{S}{2}}$ (half) 
% \item Write to all 
% \end{itemize}
% 
% Answer at least the following questions: Are \texttt{get} and \texttt{set} requests impacted the same way by different setups? If yes/no, why? Which operations become more expensive inside the middleware as the configuration changes? How does the scalability of your system compare to that of an ideal implementation? Provide the graphs and tables necessary to support your claims.

\subsection{System under test}

The second experiment aims to explore the effect of using more replication on performance.
The clients will use a 5\%-write workload.
There will be $3$, $5$ or $7$ server backends.
Three configurations of the replication factor will be explored: No replication $(R=1)$, half replication $(\lceil \frac{S}{2} \rceil$ and full replication $(R=S)$.
The details of the system under test can be found in figure \TODO{which figure?}.

\subsection{Hypothesis}

Each request is instrumented with timestamps that, among other things, indicate the time that a first request to any server was sent, and the time that the last response was received from all servers.
The time between these two timestamps is called the 'interaction time' because that is when it is interacting with the servers.
In the case of read requests, there is always only one servert to contact, so this interaction time signifies the time it takes for the server to respond.
In the case of write requests, the interaction time signifies the time it takes for all servers to respond.
In the case of no replication that is just one server, but in the case of full replication that is all the servers.

As such, we expect the interaction time for write requests to increase as we increase the replication factor.
Moreover, we expect this effect to be more prominent the more servers are used.
For read requests, we don't expect the interaction time to increase.

\subsection{Results and analysis}


\begin{figure}
  \centering
  \input{\genfile{remote-replication-effect-table.tex}}
  \caption{Replication effect experiments}
  \label{fig:replication-effect-experiment}
\end{figure}

\begin{figure}
  \centering
    \includegraphics[width=0.31\textwidth]{\plot{local-replication-effect-replication-analysis-3.png}}
    \includegraphics[width=0.31\textwidth]{\plot{local-replication-effect-replication-analysis-5.png}}
    \includegraphics[width=0.31\textwidth]{\plot{local-replication-effect-replication-analysis-7.png}}
  \caption{Effect of replication factor}
  \label{fig:replication-analysis}
\end{figure}

\begin{figure}
  \centering
    \includegraphics[width=0.48\textwidth]{\plot{local-replication-effect-replication-cost-analysis-3-read.png}}
    \includegraphics[width=0.48\textwidth]{\plot{local-replication-effect-replication-cost-analysis-3-write.png}}
    \includegraphics[width=0.48\textwidth]{\plot{local-replication-effect-replication-cost-analysis-5-read.png}}
    \includegraphics[width=0.48\textwidth]{\plot{local-replication-effect-replication-cost-analysis-5-write.png}}
    \includegraphics[width=0.48\textwidth]{\plot{local-replication-effect-replication-cost-analysis-7-read.png}}
    \includegraphics[width=0.48\textwidth]{\plot{local-replication-effect-replication-cost-analysis-7-write.png}}
  \caption{Effect of replication factor}
  \label{fig:replication-analysis}
\end{figure}

\section{Effect of Writes}

% In this section, you should study the changes in throughput and response time of your system as the percentage of write operations increases. Use a combination of 3 to 7 servers and vary the number of writes between 1\% and 10\% (e.g. 1\%, 5\% and 10\%). The experiments need to be carried out for the replication factors R=1 and R=all.  
% 
% For what number of servers do you see the biggest impact (relative to base case) on performance? Investigate the main reason for the reduced performance and provide a detailed explanation of the behavior of the system. Provide the graphs and tables necessary to support your claims.

\subsection{System under test}

In this last experiment, we investigate the results of increasing the percentage of the workload consists of write requests on performance.
Between 3 and 7 servers will be used with either no replication or full replication.
The percentage of the requests that consists of writes will be varied between 1\% and 10\%.
We call this percentage the write percentage.

\subsection{Hypothesis}

As investigated in the previous section, writes are much more expensive in a setup with full replication than in a setup with no replication.
This means that we can expect there to be a difference in performance between the no replication situation and the full replication situation for any given non-zero write percentage.
We expect that the system with full replication will perform worse and that this difference will increase as the write percentage increases.
Moreover, we expect this difference to be greater if more servers are used.
Concretely we expect a lower throughput and higher response times in the case of full replication relative to the case of no replication.
We also expect this difference to be larger for a setup with more servers and/or a greater write percentage.


\subsection{Results and analysis}
 
\begin{figure}
  \centering
  \input{\genfile{remote-write-effect-table.tex}}
  \caption{Write effect experiments}
  \label{fig:write-effect-experiment}
\end{figure}

\begin{figure}
  \centering
    \includegraphics[width=0.48\textwidth]{\plot{local-write-effect-write-analysis-tps-3.png}}
    \includegraphics[width=0.48\textwidth]{\plot{local-write-effect-write-analysis-tps-4.png}}
    \includegraphics[width=0.48\textwidth]{\plot{local-write-effect-write-analysis-tps-5.png}}
    \includegraphics[width=0.48\textwidth]{\plot{local-write-effect-write-analysis-tps-6.png}}
    \includegraphics[width=0.48\textwidth]{\plot{local-write-effect-write-analysis-tps-7.png}}
  \caption{Effect of write percentage: Throughput}
  \label{fig:write-analysis-tps}
\end{figure}
\begin{figure}
  \centering
    \includegraphics[width=0.48\textwidth]{\plot{local-write-effect-write-analysis-resp-3.png}}
    \includegraphics[width=0.48\textwidth]{\plot{local-write-effect-write-analysis-resp-4.png}}
    \includegraphics[width=0.48\textwidth]{\plot{local-write-effect-write-analysis-resp-5.png}}
    \includegraphics[width=0.48\textwidth]{\plot{local-write-effect-write-analysis-resp-6.png}}
    \includegraphics[width=0.48\textwidth]{\plot{local-write-effect-write-analysis-resp-7.png}}
  \caption{Effect of write percentage: Response time}
  \label{fig:write-analysis-resp}
\end{figure}
 
\end{document}
