\documentclass[11pt]{article}
\usepackage[a4paper, portrait, margin=1in]{geometry}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{minted}

\input{../common.tex}

\begin{document}

\title{Advanced Systems Lab (Fall'16) -- First
Milestone}

\author{\textbf{Name: \emph{\myname}}\\\textbf{Legi number: \emph{\myleginr}}}

\date{
\vspace{4cm}
\textbf{Grading} \\
\begin{tabular}{|c|c|}
\hline  \textbf{Section} & \textbf{Points} \\
\hline  1.1 &  \\ 
\hline  1.2 &  \\ 
\hline  1.3 &  \\ 
\hline  1.4 &  \\ 
\hline  2.1 &  \\ 
\hline  2.2 &  \\ 
\hline  3.1 &  \\ 
\hline  3.2 &  \\ 
\hline  3.3 &  \\ 
\hline \hline Total & \\
\hline 
\end{tabular} 
}

\maketitle
\newpage

\section{System Description}\label{sec:system-description}

\subsection{Overall Architecture}\label{sec:desc:architecture}

% Length: at most 1 page
%
% Explain how the abstract architecture we provided for you has been implemented in terms of classes and shortly outline the main design decisions.

The main class \java{RunMW}\javafile{RunMW} creates a single object of class \java{Middleware}\javafile{Middleware}.
It binds to a socket on the given Inet address and readies to accept connections using a completionhandler of class \java{AcceptCompletionHandler}\javafile{AcceptCompletionHandler}.
For every accepted connection, the initial read happens asynchronously and is completed with a shared completionhandler of class \java{InitialInputCompletionHandler}\javafile{AcceptCompletionHandler}.
When the first piece of data is available, it is parsed into a \java{Request}\javafile{request/Request} by the \java{RequestParser}\javafile{request/request_parsing/RequestParser}.
The \java{Request} and the \java{SocketChannel} for the connecting client are bundled in a so-called \java{RequestPacket}\javafile{request/RequestPacket}.
Next, the request's key is hashed to an \java{int}.
The hash modulo the number of back-end servers is used as the index of the primary server for that key.
The secondary servers are the subsequent servers, up to the replication factor.
If the request is a write request, a so-called replication counter is set in the \java{RequestPacket}.
Then the \java{RequestPacket} passed on to the \java{ServerHandler}s\javafile{ServerHandler} corresponding to the chosen servers.
Each \java{ServerHandler} contains a \java{ServerReadHandler}\javafile{ServerReadHandler} and a \java{ServerWriteHandler}\javafile{ServerWriteHandler}.

In the case of a read request, the \java{RequestPacket} is added to a \java{BlockingQueue} in the \java{ServerReadHandler}.
A pool of \java{ReadWorker}s\javafile{ServerReadHandler} dequeues the \java{RequestPacket}s one by one and synchronously queries the back-end server and simply passes on the response to the client.

In the case of a write request, the \java{RequestPacket} is added to a \java{BlockingQueue} in the \java{ServerWriteHandler}.
A single \java{WriteWorker}\javafile{ServerWriteHandler} continuously sends all available requests to the server and adds the \java{RequestPacket}s to a queue of sent requests.
Whenever any data is available, it is split into the different responses and as many \java{RequestPacket}s as there are responses are dequeued from the 'sent' queue in the same order.
Each of the corresponding \java{RequestPacket}s has their replication counter decremented.
If a replication counter reaches \java{0}, the response is forwarded to the appropriate client.

% Mark on the figure where are the points that you instrumented the architecture (see Section~2.3 of the Project Description) and give the different timestamps a name that you\textbf{ will use throughout the three milestones }whenever referencing measurements (e.g., $T_{requestreceived}$, $T_{responsesent}$).
% 
% Reference throughout the report all relevant java source files, result files, etc. by providing the gitlab link in a footnote, for instance\footnote{\url{https://gitlab.inf.ethz.ch/zistvan/asl-fall16-project/blob/master/src/ch/ethz/SomeClass.java}}. An exception to this rule is the referencing of log files belonging to experiments. These should be referenced by an ID, or short name, and there has to be a table at the end of the report mapping these to files in the git repository.

\includegraphics[width=0.5\textwidth]{\asset{architecture.png}}

\javafile{Middleware}


\subsection{Load Balancing and Hashing}\label{sec:desc:hashing}

% Length: at most 1 page
% 
% Explain what hash function you use for load balancing and how you implement the selection of servers. Give a short reasoning on why the chosen scheme should uniformly distribute load (assuming no skew on the client side).

\subsection{Write Operations and Replication}\label{sec:desc:writes}

% Length: at most 1 page
% 
% Provide a short description of how the writes are handled in the middleware. Explain how the replicated case differs from the simple ``write one'' scenario.
% 
% Give an estimate of the latencies the writing operation will incur, and generalize it to the replicated case. What do you expect will limit the rate at which writes can be carried out in the system (if anything)?

\subsection{Read Operations and Thread Pool}\label{sec:desc:reads}

% Length: at most 1 page
%
% How are reads handled in the system? How does the middleware make sure that the queue between the ``main receiving'' thread and the read handlers is not accessed in unsafe concurrent manner? Explain what is the relation between threads in the thread pool and connections to servers.



\section{Memcached Baselines}\label{sec:baseline}

% This section will report experimental results. All such parts will start with a short description of the experimental setup. The log files should be identified by a short name, or number, which will be explicitly listed at the end of the document (see Logfile Listing at the end).  \textbf{If this table is missing or the logfiles listed can't be found in your repository the experiment could be considered invalid, and no points will be awarded!}
% For baseline measurement of memcached provide \textbf{two} graphs (Section~\ref{sec:baseline:tput} and \ref{sec:baseline:rt}), one with aggregated throughput and one with average response time and standard deviation as a function of number of virtual clients. Increase these in steps from 1 to 128. Give a short explanation of memcache's behavior and find the number of virtual clients that saturate the server.

% \small{
%   \smallskip
%   \begin{tabular}{|c|c|}
%     \hline Number of servers & 1 \\
%     \hline Number of client machines & 1 to 2 \\
%     \hline Virtual clients / machine & 1 to 64 \\
%     \hline Workload & Key 16B, Value 128B, Writes 1\% \footnotemark \\
%     \hline Middleware & Not present \\
%     \hline Runtime x repetitions & 30s x 5 \\
%     \hline Log files & microbench1, microbench2, \ldots \\
%     \hline
%   \end{tabular} }
% 
% \footnotetext{As starting point use the workloads provided in \url{http://www.systems.ethz.ch/sites/default/files/file/asl2016/memaslap-workloads.tar}. Use by default the \emph{small} workload. In later experiments you can and should change read-write ratios and potentially use other value sizes.}


\subsection{Throughput}\label{sec:baseline:tput}

\includegraphics[width=0.5\textwidth]{\plot{remote-baseline-experiment-tps-1.png}}
\includegraphics[width=0.5\textwidth]{\plot{remote-baseline-experiment-tps-2.png}}

\subsection{Response time}\label{sec:baseline:rt}

\includegraphics[width=0.5\textwidth]{\plot{remote-baseline-experiment-avg-1.png}}
\includegraphics[width=0.5\textwidth]{\plot{remote-baseline-experiment-avg-2.png}}
\includegraphics[width=0.5\textwidth]{\plot{remote-baseline-experiment-avg-combined.png}}

\section{Stability Trace}\label{sec:trace}

% In this section you will have to show that the middleware is functional and it can handle a long-running workload without crashing or degrading in performance. For this you will run it with full replication for one hour connected to three memcache instances and three load generator machines.
% You will have to provide two graphs. The x-axis is time and the y-axis is either throughput or response time. Include standard deviation whenever applicable.
% 
% \small{
%   \smallskip
%   \begin{tabular}{|c|c|}
%     \hline Number of servers & 3 \\
%     \hline Number of client machines & 3 \\
%     \hline Virtual clients / machine &  64 (explain if chosen otherwise) \\
%     \hline Workload & Key 16B, Value 128B, Writes 1\% (see footnote) \\
%     \hline Middleware & Replicate to all (R=3) \\
%     \hline Runtime x repetitions & 1h x 1 \\
%     \hline Log files & trace1, \ldots \\
%     \hline
%   \end{tabular} }



\subsection{Throughput}

\subsection{Response time}

\subsection{Overhead of middleware}

% Compare the performance you expect based on the baselines and the one you observe in the trace and quantify the overheads introduced by the middleware (if any), Look at both response time and achievable throughput when making the comparison. Provide an overview of the overheads in a table form.


\pagebreak

\section*{Logfile listing}

% \begin{tabular}{|c|l|}
%   \hline \textbf{Short name }& \textbf{Location} \\
%   \hline microbench1 & \url{https://gitlab.inf.ethz.ch/.../baseline/logfile.log} \\
%   \hline microbench2 & \url{https://gitlab.inf.ethz.ch/.../baseline/logfile2.log} \\
%   \hline trace1 & \url{https://gitlab.inf.ethz.ch/.../baseline/logfile.log} \\
%   \hline \dots & \dots \\
%   \hline
% \end{tabular}


\end{document}
